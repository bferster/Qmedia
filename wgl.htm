
<!DOCTYPE html>
<html lang="en">
<head>
	<title>3D test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
 	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>	
	<script src="lib/wgl/three.min.js"></script>
	<script src="lib/wgl/loaders/OBJLoader.js"></script>
	<script src="lib/wgl/controls/OrbitControls.js"></script>
	<script src="lib/wgl/controls/FirstPersonControls.js"></script>
	<script src="lib/wgl/Detector.js"></script>
<style type="text/css">
	body { font-family:Verdana,Geneva,sans-serif; font-size:xx-small;margin:0px;padding:0px }
</style>
		
<script>

	var container;																// Iframe to hold WebGL player
	var startTime;																// Current play time
	var keys=[];																// Hold keyframes
	var camera,scene,renderer,controls,clock;									// WebGL guts
	var qe=new QmediaEvents("QmediaAssess");									// Alloc events library
	var controlMode="orbit";

	$(document).ready(function() {												// When loaded
  		container=document.createElement('div');								// Make container div
		document.body.appendChild(container);									// Add to body
 		camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,2000);	// Create camera
		SetControlMode(controlMode);											// Default control mode
		renderer=new THREE.WebGLRenderer();										// Create renderer
		renderer.setSize(window.innerWidth,window.innerHeight-2);				// Set remder size
		container.appendChild(renderer.domElement);								// Add renderer
		window.addEventListener('resize',onWindowResize,false );				// Add resize event
		
		// START CONTENT
		
		scene=new THREE.Scene();												
		var manager=new THREE.LoadingManager();
		manager.onProgress=function(item,loaded,total) { console.log(item,loaded,total); };
		
		// LIGHTING
		
		var ambient=new THREE.AmbientLight(0x101030);
		scene.add(ambient);
		var directionalLight=new THREE.DirectionalLight(0xffeedd);
		directionalLight.position.set(0,0,1);
		scene.add(directionalLight);

		// TEXTURE

		var texture=new THREE.Texture();
		var loader=new THREE.ImageLoader(manager);
		loader.load('wgl/map.jpg',function(image) {
			texture.name="tex";
			texture.image=image;
			texture.needsUpdate=true;
			});
		
		// MODEL
		
		var loader=new THREE.OBJLoader(manager);
		loader.load('wgl/male02.obj',function(object) {
			object.traverse(function(child) {
				if (child instanceof THREE.Mesh) 
					child.material.map=texture;
				});
			object.position.y=-80;
			scene.add(object);		
			});

		// SKYBOX
		
		var urls=['wgl/px.jpg','wgl/nx.jpg','wgl/py.jpg','wgl/ny.jpg','wgl/pz.jpg','wgl/nz.jpg'];
		var reflectionCube = THREE.ImageUtils.loadTextureCube(urls);
		reflectionCube.format = THREE.RGBFormat;
		var refractionCube = new THREE.CubeTexture( reflectionCube.image, new THREE.CubeRefractionMapping() );
		refractionCube.format = THREE.RGBFormat;
		var cubeMaterial3 = new THREE.MeshLambertMaterial( { color: 0xff6600, ambient: 0x993300, envMap: reflectionCube, combine: THREE.MixOperation, reflectivity: 0.3 } );
		var cubeMaterial2 = new THREE.MeshLambertMaterial( { color: 0xffee00, ambient: 0x996600, envMap: refractionCube, refractionRatio: 0.95 } );
		var cubeMaterial1 = new THREE.MeshLambertMaterial( { color: 0xffffff, ambient: 0xaaaaaa, envMap: reflectionCube } )
		var shader = THREE.ShaderLib[ "cube" ];
		shader.uniforms[ "tCube" ].value=reflectionCube;
		var material = new THREE.ShaderMaterial( {
			fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader,
			uniforms: shader.uniforms, depthWrite: false, side: THREE.BackSide
			}),
		mesh=new THREE.Mesh( new THREE.BoxGeometry( 800, 800, 800 ), material );
		scene.add(mesh);

		// END CONTENT

		Animate();																	// Animate
		$("body").append("<div style='position:absolute;top:0px;z-index:1000;color:white'><br> &nbsp; Hit the 'c' key to change control mode, 'h' to go home.</div>")
		qe.SendMessage("ready","");													// Send ready message
	
	});

	function onWindowResize() 													// ON WINDOW RESIZE
	{
		camera.aspect=window.innerWidth/window.innerHeight;							// Set apsect
		camera.updateProjectionMatrix();											// Reset matrix
		renderer.setSize(window.innerWidth,window.innerHeight-2);					// Reset render size
	}

	function Animate() 															// ANIMATION LOOP
	{
		requestAnimationFrame(Animate);												// Set timer
		if (controls && (controlMode != "goto"))									// If controls set
			controls.update(clock.getDelta());										// Update position?
		renderer.render(scene,camera);												// Render
	}

	function SetControlMode(mode)												// SET CAMERA CONTROL MODE
	{
      	clock=new THREE.Clock();													// Reset clock
	  	controlMode=mode;															// Set mode flag
 		controls=null;																// No controls
		switch (controlMode) {														// Route on mode
 			case "orbit":
    			controls=new THREE.OrbitControls(camera);
  				controls.damping = 0.2;
     			break;
   			case "first":
     			controls=new THREE.FirstPersonControls(camera);
 		       	controls.lookSpeed = 0.05;
		        controls.movementSpeed = 50;
		        controls.noFly = true;
		        controls.lookVertical = true;
		        controls.constrainVertical = false;
		        controls.verticalMin = 1.0;
		        controls.verticalMax = 2.0;
		        controls.lon=-90;
		        controls.lat=0;
		        break;
 			case "key": case "":
				var i,s,e,pct;
				controls={};
   				if (controlMode == "key")										// If key mode
					startTime=new Date().getTime()/1000;						// Set start
 	    			controls.update=function() {							// UPDATE FUNCTION
						var time=new Date().getTime()/1000-startTime;			// Get now
						for (i=keys.length-1;i>=0;--i) 							// Work backwards
							if (keys[i][0] <= time)								// If it's this one
								break;											// Stop looking
						if (i < 0)												// Didn't find one
							return;												// Quit
						s=e=keys[i];											// Point to start			
						if (i <	keys.length-1)									// If not last
							e=keys[i+1];										// Point at end				
						pct=e[0]-s[0];											// Duration
						if (pct)	pct=(time-s[0])/pct;						// Point within key 0-1
						if (s[7] == 2)											// Slow in and out
							pct=1.0-((Math.cos(3.1414*pct)+1)/2.0);				// Full cosine curve
						else if (s[7] == 1)										// Slow in
							pct=1.0-(Math.cos(1.5707*pct));						// 1st quadrant of cosine curve
						else if (s[7] == 3)										// Slow out
							pct=1.0-(Math.cos(1.5707+(1.5707*pct))+1.0);		// 2nd quadrant of cosine curve
						camera.position.x=s[1]-0+(e[1]-s[1])*pct;				// Get val
						camera.position.y=s[2]-0+(e[2]-s[2])*pct;				// Get val
						camera.position.z=s[3]-0+(e[3]-s[3])*pct;				// Get val
						camera.rotation.x=s[4]-0+(e[4]-s[4])*pct;				// Get val
						camera.rotation.y=s[5]-0+(e[5]-s[5])*pct;				// Get val
						camera.rotation.z=s[6]-0+(e[6]-s[6])*pct;				// Get val
						};
	 				break;
       		}
      	}
 		
	keys.push([0,0,0,300, 	0,0,0,1]);
	keys.push([3,100,0,300,	0,0,0,0]);
	keys.push([6,200,0,300,	0,3,0,3]);
	keys.push([9,0,0,300, 	0,0,0,1]);
	
	function trace(msg, p1, p2, p3, p4)										// CONSOLE 
	{
		if (p4 != undefined)
			console.log(msg,p1,p2,p3,p4);
		else if (p3 != undefined)
			console.log(msg,p1,p2,p3);
		else if (p2 != undefined)
			console.log(msg,p1,p2);
		else if (p1 != undefined)
			console.log(msg,p1);
		else
			console.log(msg);
	}


	$("body").on("keydown", function(e) {							// KEYDOWN HANDLER
		if (e.which == 13) 
			trace(camera.rotation)
		if (e.which == 67) {
			if (controlMode == "orbit") 
				controlMode="first";
			else 
				controlMode="orbit";
			SetControlMode(controlMode);
			}
		if (e.which == 71) {
			SetControlMode("goto");
			var str=prompt("Type Go to pos: x=,y=...");
			var v=str.split(",");
			for (var i=0;i<v.length;++i) {
				if (v[i].split("=")[0] == "x")	camera.position.x=v[i].split("=")[1]-0;
				if (v[i].split("=")[0] == "y")	camera.position.y=v[i].split("=")[1]-0;
				if (v[i].split("=")[0] == "z")	camera.position.z=v[i].split("=")[1]-0;
				if (v[i].split("=")[0] == "xr")	camera.rotation.x=v[i].split("=")[1]-0;
				if (v[i].split("=")[0] == "yr")	camera.rotation.y=v[i].split("=")[1]-0;
				if (v[i].split("=")[0] == "zr")	camera.rotation.z=v[i].split("=")[1]-0;
				}
			SetControlMode("orbit");
			}
		if (e.which == 75) 
			SetControlMode("key");

		});			


	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// QMEDIA EVENT HANDLING
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	function QmediaEventHandler(e)											// ON SHIVA EVENT
	{
		var v=e.data.split("|");												// Split into parts													
		if (v[0] == "ShivaAct=data") {											// If a data 
			keys=v[1].split(';')												// Get key sets
//			keys="0,0,0,300,0,0,0,1;3,100,0,300,0,0,0,3;6,200,0,300,0,3,0,0".split(';');
			for (var i=0;i<keys.length;++i)										// For each set	
				keys[i]=keys[i].split(',');										// Make into array
			}											
		else if (v[0] == "ShivaAct=goto") {										// If goto
			SetControlMode("goto");												// Control mode
			camera.position.x=s[1];												// Get val
			camera.position.y=s[2];												// Get val
			camera.position.z=s[3];												// Get val
			camera.rotation.x=s[4];												// Get val
			camera.rotation.y=s[5];												// Get val
			camera.rotation.z=s[6];												// Get val
			}
		else if (v[0] == "ShivaAct=play") 										// If play
			SetControlMode("key");												// Play it

		else if (v[0] == "ShivaAct=pause") 										// If pause
			;																	// Pause it
		}	

	function QmediaEvents(id)												// CONSTRUCTOR
	{
		if (window.addEventListener) 											// If supported this way
			window.addEventListener("message",QmediaEventHandler,false);		// Add event handler
		else																	// Use other method
			window.attachEvent("message",QmediaEventHandler);					// Add handler
		this.header=id+"=";														// Set header
	}
	
	QmediaEvents.prototype.SendMessage=function(cmd, msg)					// SEND MESSAGE TO CONTAINER
		{
		var str=this.header+cmd+"|extra";										// Add header				
		if (msg) str+="|"+msg;													// If more to it, add
		if (window.parent)														// If has a parent
			window.parent.postMessage(str,"*");									// Send message to parent wind
		else																	// Local	
			window.postMessage(str,"*");										// Send message to wind
	}

</script>
</body>
</html>
