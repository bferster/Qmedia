
<!DOCTYPE html>
<html lang="en">
<head>
	<title>3D test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
 	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>	
	<script src="lib/wgl/three.min.js"></script>
	<script src="lib/wgl/loaders/OBJLoader.js"></script>
	<script src="lib/wgl/controls/OrbitControls.js"></script>
	<script src="lib/wgl/controls/FirstPersonControls.js"></script>
	<script src="lib/wgl/Detector.js"></script>
<style type="text/css">
	body { font-family:Verdana,Geneva,sans-serif; font-size:xx-small;margin:0px;padding:0px }
</style>
		
<script>

	var container,obj;
	var camera,scene,renderer,controls,clock;
	var mouseX=0,mouseY=0;
	var qe=new QmediaEvents("QmediaAssess");									// Alloc events library
	var controlMode="orbit";
	init();
	animate();

	function init() {
  		container=document.createElement('div');
		document.body.appendChild(container);

		SetControlMode(controlMode);
		scene=new THREE.Scene();
		
		var ambient=new THREE.AmbientLight(0x101030);
		scene.add(ambient);

		var directionalLight=new THREE.DirectionalLight(0xffeedd);
		directionalLight.position.set(0,0,1);
		scene.add(directionalLight);

		var manager=new THREE.LoadingManager();
		manager.onProgress=function(item,loaded,total ) {
			console.log(item,loaded,total);
			};

		var texture=new THREE.Texture();
		var loader=new THREE.ImageLoader(manager);
		loader.load('wgl/map.jpg',function(image) {
			texture.name="tex";
			texture.image=image;
			texture.needsUpdate=true;
			});

		var loader=new THREE.OBJLoader(manager);
		loader.load('wgl/male02.obj',function(object) {
			object.traverse(function(child) {
				if (child instanceof THREE.Mesh) {
					child.material.map=texture;
				}
			obj=object;
			});

		object.position.y=-80;
		scene.add(object);		
		qe.SendMessage("ready","");												// Send ready message
		});

	var urls=['wgl/px.jpg','wgl/nx.jpg','wgl/py.jpg','wgl/ny.jpg','wgl/pz.jpg','wgl/nz.jpg'];
	var reflectionCube = THREE.ImageUtils.loadTextureCube(urls);
	reflectionCube.format = THREE.RGBFormat;
	var refractionCube = new THREE.CubeTexture( reflectionCube.image, new THREE.CubeRefractionMapping() );
	refractionCube.format = THREE.RGBFormat;

	var cubeMaterial3 = new THREE.MeshLambertMaterial( { color: 0xff6600, ambient: 0x993300, envMap: reflectionCube, combine: THREE.MixOperation, reflectivity: 0.3 } );
	var cubeMaterial2 = new THREE.MeshLambertMaterial( { color: 0xffee00, ambient: 0x996600, envMap: refractionCube, refractionRatio: 0.95 } );
	var cubeMaterial1 = new THREE.MeshLambertMaterial( { color: 0xffffff, ambient: 0xaaaaaa, envMap: reflectionCube } )

	var shader = THREE.ShaderLib[ "cube" ];
	shader.uniforms[ "tCube" ].value=reflectionCube;

	var material = new THREE.ShaderMaterial( {
		fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader,
		uniforms: shader.uniforms, depthWrite: false, side: THREE.BackSide
		}),

	mesh=new THREE.Mesh( new THREE.BoxGeometry( 800, 800, 800 ), material );
	scene.add( mesh );

	renderer=new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth,window.innerHeight-2);
	container.appendChild(renderer.domElement);
	window.addEventListener('resize',onWindowResize,false );
	animate();
	}

	function onWindowResize() 
	{
		trace(scene)
		camera.aspect=window.innerWidth/window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth,window.innerHeight-2);
	}

	function animate() 
	{
		requestAnimationFrame(animate);
		if (controls)
			controls.update(clock.getDelta());
		render();
	}

	function SetControlMode(mode)
	{
      	clock=new THREE.Clock();
	  	controlMode=mode;
 		camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,2000);
		controls=null;
		switch (controlMode) {
 			case "orbit":
    			controls=new THREE.OrbitControls(camera);
  				controls.damping = 0.2;
	 			camera.position.z=300;
     			break;
   			case "first":
     			controls=new THREE.FirstPersonControls(camera);
 				camera.position.z=500;
		       	controls.lookSpeed = 0.05;
		        controls.movementSpeed = 50;
		        controls.noFly = true;
		        controls.lookVertical = true;
		        controls.constrainVertical = false;
		        controls.verticalMin = 1.0;
		        controls.verticalMax = 2.0;
		        controls.lon=-90;
		        controls.lat=0;
		        break;
 			case "key":
				var i,s,e,pct;
				controls={};
 				camera.position.z=300;
    				controls.update=function() {
					var time=clock.elapsedTime;									// Get elapsed time
					for (i=keys.length-1;i>=0;--i) 								// Work backwards
						if (keys[i].t <= time)									// If it's this one
							break;												// Stop looking
					if (i < 0)													// Didn't find one
						return;													// Quit
					
					s=e=keys[i];												// Point to start			
					if (i <	keys.length-1)										// If not last
						e=keys[i+1];											// Point at end				
					pct=e.t-s.t;												// Duration
					if (pct)	pct=(time-s.t)/pct;								// Point within key 0-1
					if (s.e == 2)												// Slow in and out
						pct=1.0-((Math.cos(3.1414*pct)+1)/2.0);					// Full cosine curve
					else if (s.e == 1)											// Slow in
						pct=1.0-(Math.cos(1.5707*pct));							// 1st quadrant of cosine curve
					else if (s.e == 3)											// Slow out
						pct=1.0-(Math.cos(1.5707+(1.5707*pct))+1.0);			// 2nd quadrant of cosine curve
					camera.position.x=s.x+(e.x-s.x)*pct;						// Get val
					camera.position.y=s.y+(e.y-s.y)*pct;						// Get val
					camera.position.z=s.z+(e.z-s.z)*pct;						// Get val
					camera.rotation.x=s.xr+(e.xr-s.xr)*pct;						// Get val
					camera.rotation.y=s.yr+(e.yr-s.yr)*pct;						// Get val
					camera.rotation.z=s.zr+(e.zr-s.zr)*pct;						// Get val
					};
 				break;
       		}
      	}
 		
	var keys=[];
	keys.push({t:0,x:0,y:0,z:300,xr:0,yr:3,zr:0,e:0});
	keys.push({t:5,x:100,y:0,z:300,xr:0,yr:0,zr:0,e:3});
	keys.push({t:10,x:200,y:0,z:300,xr:0,yr:0,zr:0,e:0});
	
	function GetKey(time) 													// GET KEY TO ANIMATE
	{
		var i;
		return -1;																// Not found
	}
	
	function render() 
	{
		renderer.render(scene,camera);
	}

	function trace(msg, p1, p2, p3, p4)										// CONSOLE 
	{
		if (p4 != undefined)
			console.log(msg,p1,p2,p3,p4);
		else if (p3 != undefined)
			console.log(msg,p1,p2,p3);
		else if (p2 != undefined)
			console.log(msg,p1,p2);
		else if (p1 != undefined)
			console.log(msg,p1);
		else
			console.log(msg);
	}


		$("body").on("keydown", function(e) {							// Handle filter
			if (e.which == 13) 
				trace(camera.rotation)
			if (e.which == 67) {
				if (controlMode == "orbit") 
  					controlMode="first";
  				else 
					controlMode="orbit";
   				SetControlMode(controlMode);
  				}
			if (e.which == 71) {
				SetControlMode("key");
				var str=prompt("Type Go to pos: x=,y=...");
				var v=str.split(",");
				for (var i=0;i<v.length;++i) {
					if (v[i].split("=")[0] == "x")	camera.position.x=v[i].split("=")[1]-0;
					if (v[i].split("=")[0] == "y")	camera.position.y=v[i].split("=")[1]-0;
					if (v[i].split("=")[0] == "z")	camera.position.z=v[i].split("=")[1]-0;
					if (v[i].split("=")[0] == "xr")	camera.rotation.x=v[i].split("=")[1]-0;
					if (v[i].split("=")[0] == "yr")	camera.rotation.y=v[i].split("=")[1]-0;
					if (v[i].split("=")[0] == "zr")	camera.rotation.z=v[i].split("=")[1]-0;
					}
				}

			});			
	


	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// QMEDIA EVENT HANDLING
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
	function QmediaEventHandler(e)											// ON SHIVA EVENT
	{
		var v=e.data.split("|");												// Split into parts													
		if (v[0] == "ShivaAct=data") {											// If a data 
			aData=$.parseJSON(v[1]);											// Convert to obj
			Draw(0,false);														// Draw page
			}												
	}	

	function QmediaEvents(id)												// CONSTRUCTOR
	{
		if (window.addEventListener) 											// If supported this way
			window.addEventListener("message",QmediaEventHandler,false);		// Add event handler
		else																	// Use other method
			window.attachEvent("message",QmediaEventHandler);					// Add handler
		this.header=id+"=";														// Set header
	}
	
	QmediaEvents.prototype.SendMessage=function(cmd, msg)					// SEND MESSAGE TO CONTAINER
		{
		var str=this.header+cmd+"|extra";										// Add header				
		if (msg) str+="|"+msg;													// If more to it, add
		if (window.parent)														// If has a parent
			window.parent.postMessage(str,"*");									// Send message to parent wind
		else																	// Local	
			window.postMessage(str,"*");										// Send message to wind
	}

</script>
</body>
</html>
